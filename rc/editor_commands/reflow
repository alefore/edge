// Reflows the current paragraph, based on variables `line_prefix_characters`
// and `paragraph_line_prefix_characters`, to make each line (save for the last
// one) as long as possible but shorter than the value of variable `line_width`.
#include "lib/strings"

// Should words longer than `line_width` be broken? If false, we'll only break
// lines at spaces (never breaking a word). If true, we'll never let lines
// exceed the desired `line_width`.
bool break_words = false;

// Checks if a given line starts with the prefix. The line must have an
// additional character after the prefix for this to be true (in other words,
// this is false if the line is equal to the prefix).
bool LineHasPrefix(string prefix, int line_number) {
  string contents = buffer.line(line_number);
  return contents.starts_with(prefix) && contents.size() > prefix.size();
}

bool LineIsInParagraph(string prefix, int line_number) {
  string contents = buffer.line(line_number);
  return GetPrefix(contents, buffer.paragraph_line_prefix_characters())
                 .size() >= prefix.size() &&
         contents.size() > prefix.size();
}

// Moves the current position to the first line that follows a line that doesn't
// have a given prefix.
//
// We use `LineIsInParagraph` to allow the first line in the paragraph to have a
// different prefix.
//
// For example, in Markdown, with the cursor at "hey":
//
//   * alejandro
//     forero
//     cuervo
//   * bar
//     foo
//     hey <- cursor here.
//     there
//
// We want this result:
//
//   * alejandro
//     forero
//     cuervo
//   * bar foo hey there
//
// That is: the paragraph begins at "bar", not at "foo" nor at "alejandro".
void ScrollBackToBeginningOfParagraph(string prefix) {
  SetStatus("Scrolling back to beginning of paragraph.");
  int line = buffer.position().line();
  while (line > 0 && LineHasPrefix(prefix, line - 1)) {
    line--;
  }

  if (line > 0 && LineIsInParagraph(prefix, line - 1)) {
    line--;
  }

  buffer.set_position(LineColumn(line, 0));
}

// Folds into the current line all lines in the current paragraph (according to
// LineHasPrefix). The end result is that the current line will contain the
// entire paragraph (probably being far larger than `buffer.line_width()`).
void FoldNextLineWhilePrefixIs(string prefix) {
  SetStatus("Folding paragraph into a single line.");
  int line = buffer.position().line();
  while (line + 1 < buffer.line_count() && LineHasPrefix(prefix, line + 1)) {
    buffer.set_position(LineColumn(line, buffer.line(line).size()));
    if (buffer.position().column() > prefix.size()) {
      buffer.InsertText(" ");  // To avoid a space in the first line.
    }
    int prefix_to_delete =
        buffer.line(line + 1).find_first_not_of(" ", prefix.size());
    buffer.DeleteCharacters(1 + prefix_to_delete);
  }
}

// Deletes length characters starting at start and breaks the line.
void BreakAt(string prefix, int start, int length) {
  buffer.set_position(LineColumn(buffer.position().line(), start));
  buffer.DeleteCharacters(length);
  buffer.InsertText("\n" + prefix);
}

void BreakLine(string prefix, int line_width) {
  SetStatus("Breaking line by line width: " + line_width.tostring());
  while (buffer.line(buffer.position().line()).size() > line_width) {
    string s = buffer.line(buffer.position().line());

    // The last space before line_width.
    int last_space = s.find_last_of(" ", line_width);
    if (last_space != -1 && last_space > prefix.size()) {
      // We were able to find a space after the prefix.
      //
      // Find the last non-space character preceeding it.
      int last_char = s.find_last_not_of(" ", last_space);
      if (last_char == -1) {
        SetStatus("Giving up: couldn't find start of break.");
        return;
      }
      BreakAt(prefix, last_char + 1, last_space - last_char);
    } else {  // No space found after the prefix and before line_width.
      // Find the first non-space character after line_width.
      int break_at =
          break_words ? line_width : s.find_first_of(" ", line_width);
      if (break_at == -1) {
        SetStatus("We're done: No space remains.");
        return;
      }
      int next_char = s.find_first_of(buffer.word_characters(), break_at);
      if (next_char == -1) {
        SetStatus("We're done: Only spaces now.");
        return;
      }
      BreakAt(prefix, break_at, next_char - break_at);
    }
  }
}

buffer.PushTransformationStack();

string prefix = GetPrefix(buffer.line(buffer.position().line()),
                          buffer.line_prefix_characters());

ScrollBackToBeginningOfParagraph(prefix);
LineColumn starting_position = buffer.position();

// This is in case the first line in the paragraph has spaces that should be
// removed.
buffer.set_position(LineColumn(starting_position.line(), prefix.size()));
buffer.InsertText("\n" + prefix);
buffer.set_position(starting_position);

FoldNextLineWhilePrefixIs(prefix);
buffer.set_position(starting_position);

BreakLine(prefix, buffer.line_width());
buffer.set_position(starting_position);

buffer.PopTransformationStack();
