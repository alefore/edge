// Reflows the current paragraph, based on variables `line_prefix_characters`
// and `paragraph_line_prefix_characters`, to make each line (save for the last
// one) as long as possible but shorter than the value of variable `line_width`.

#include "lib/strings"

// Should words longer than `line_width` be broken? If false, we'll only break
// lines at spaces (never breaking a word). If true, we'll never let lines
// exceed the desired `line_width`.
bool break_words = false;

// Folds into the current line all lines in the current paragraph (according to
// LineHasPrefix). The end result is that the current line will contain the
// entire paragraph (probably being far larger than `buffer.line_width()`).
void FoldNextLineWhilePrefixIs(string prefix) {
  SetStatus("Folding paragraph into a single line.");
  int line = buffer.position().line();
  bool first_line = true;
  while (line + 1 < buffer.line_count() && LineHasPrefix(prefix, line + 1) &&
         (first_line || GetPrefix(buffer.line(line + 1),
                                  buffer.paragraph_line_prefix_characters()) ==
                            GetPrefix(buffer.line(line + 1),
                                      buffer.line_prefix_characters()))) {
    buffer.ApplyTransformation(
        SetPositionTransformation(LineColumn(line, buffer.line(line).size())));
    if (buffer.position().column() > prefix.size()) {
      // Avoid a space in the first line:
      buffer.ApplyTransformation(
          InsertTransformationBuilder().set_text(" ").build());
    }
    int prefix_to_delete =
        buffer.line(line + 1).find_first_not_of(" ", prefix.size());
    buffer.ApplyTransformation(
        DeleteTransformationBuilder()
            .set_modifiers(Modifiers().set_repetitions(1 + prefix_to_delete))
            .build());
    first_line = false;
  }
}

// Deletes length characters starting at start and breaks the line.
void BreakAt(string prefix, int start, int length) {
  buffer.ApplyTransformation(
      SetPositionTransformation(LineColumn(buffer.position().line(), start)));
  buffer.ApplyTransformation(
      DeleteTransformationBuilder()
          .set_modifiers(Modifiers().set_repetitions(length))
          .build());
  buffer.ApplyTransformation(
      InsertTransformationBuilder().set_text("\n" + prefix).build());
}

void BreakLine(string prefix, int line_width) {
  SetStatus("Breaking line by line width: " + line_width.tostring());
  while (buffer.line(buffer.position().line()).size() > line_width) {
    string s = buffer.line(buffer.position().line());

    // The last space before line_width.
    int last_space = s.find_last_of(" ", line_width);
    if (last_space != -1 && last_space > prefix.size()) {
      // We were able to find a space after the prefix.
      //
      // Find the last non-space character preceeding it.
      int last_char = s.find_last_not_of(" ", last_space);
      if (last_char == -1) {
        SetStatus("Giving up: couldn't find start of break.");
        return;
      }
      BreakAt(prefix, last_char + 1, last_space - last_char);
    } else {  // No space found after the prefix and before line_width.
      // Find the first non-space character after line_width.
      int break_at =
          break_words ? line_width : s.find_first_of(" ", line_width);
      if (break_at == -1) {
        SetStatus("We're done: No space remains.");
        return;
      }
      int next_char = s.find_first_of(buffer.symbol_characters(), break_at);
      if (next_char == -1) {
        SetStatus("We're done: Only spaces now.");
        return;
      }
      BreakAt(prefix, break_at, next_char - break_at);
    }
  }
}

buffer.PushTransformationStack();

string prefix = GetPrefix(buffer.line(buffer.position().line()),
                          buffer.line_prefix_characters());

ScrollBackToBeginningOfParagraph(prefix);
LineColumn starting_position = buffer.position();

// This is in case the first line in the paragraph has spaces that should be
// removed.
buffer.ApplyTransformation(SetPositionTransformation(
    LineColumn(starting_position.line(), prefix.size())));
buffer.ApplyTransformation(
    InsertTransformationBuilder().set_text("\n" + prefix).build());
buffer.ApplyTransformation(SetPositionTransformation(starting_position));

FoldNextLineWhilePrefixIs(prefix);
buffer.ApplyTransformation(SetPositionTransformation(starting_position));

BreakLine(prefix, buffer.line_width());
buffer.ApplyTransformation(SetPositionTransformation(starting_position));

buffer.PopTransformationStack();
