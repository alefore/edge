#include "lib/strings"

double total_columns = 80.0;
double total_lines = 25.0;

bool simple_characters = false;
bool delete_mode = false;
bool bold_mode = false;

LineColumn source = LineColumn(0, 0);

void ShapesSetStatus(string description) {
  SetStatus("Shapes: " + description);
}

int Min(int x, int y) { return x <= y ? x : y; }
int Max(int x, int y) { return x >= y ? x : y; }

double Abs(double x) {
  if (x >= 0.0)
    return x;
  else
    return -x;
}

void PadToLineColumn(LineColumn position) {
  buffer.set_position(position);
  if (buffer.line_count() <= position.line()) {
    buffer.set_position(LineColumn(buffer.line_count(), 0));
    buffer.InsertText("\n" * (position.line() + 1 - buffer.line_count()));
  }
  string line = buffer.line(position.line());
  int insertions = Max(0, position.column() - line.size());
  buffer.set_position(position);
  buffer.InsertText(" " * insertions);
}

void DrawPosition(LineColumn position, string text) {
  string line = buffer.line(position.line());
  PadToLineColumn(position);
  if (line.size() > position.column()) {
    buffer.DeleteCharacters(Min(line.size() - position.column(), text.size()));
  }
  buffer.InsertText(text);
}

string GetCode(bool up, bool down, bool left, bool right, bool up_bold,
               bool down_bold, bool left_bold, bool right_bold) {
  if (simple_characters) {
    int count =
        (up ? 1 : 0) + (down ? 1 : 0) + (left ? 1 : 0) + (right ? 1 : 0);
    if (!up && !down && !left && !right) {
      return " ";
    } else if (!up && !down) {
      return "-";
    } else if (!left && !right) {
      return "|";
    } else if (count == 2 && up && right) {
      return "`";
    } else if (count == 2 && down && right) {
      return ",";
    } else if (count == 2 && up && left) {
      return "´";
    } else if (count == 2 && down && left) {
      return ".";
    } else {
      return "+";
    }
  }

  if (up_bold) {
    if (down_bold) {
      if (left_bold) {
        if (right_bold) {
          return "╋";
        } else if (right) {
          return "╉";
        } else {
          return "┫";
        }
      } else if (left) {
        if (right_bold) {
          return "╊";
        } else if (right) {
          return "╂";
        } else {
          return "┨";
        }
      } else {
        if (right_bold) {
          return "┣";
        } else if (right) {
          return "┠";
        } else {
          return "┃";
        }
      }
    } else if (down) {
      if (left_bold) {
        if (right_bold) {
          return "╇";
        } else if (right) {
          return "╃";
        } else {
          return "┩";
        }
      } else if (left) {
        if (right_bold) {
          return "╄";
        } else if (right) {
          return "╀";
        } else {
          return "┦";
        }
      } else {
        if (right_bold) {
          return "┡";
        } else if (right) {
          return "┞";
        } else {
          return "╿";
        }
      }
    } else {
      if (left_bold) {
        if (right_bold) {
          return "┻";
        } else if (right) {
          return "┹";
        } else {
          return "┛";
        }
      } else if (left) {
        if (right_bold) {
          return "┺";
        } else if (right) {
          return "┸";
        } else {
          return "┚";
        }
      } else {
        if (right_bold) {
          return "┗";
        } else if (right) {
          return "┖";
        } else {
          return "╵";  // Best fit.
        }
      }
    }
  } else if (up) {
    if (down_bold) {
      if (left_bold) {
        if (right_bold) {
          return "╈";
        } else if (right) {
          return "╅";
        } else {
          return "┪";
        }
      } else if (left) {
        if (right_bold) {
          return "╆";
        } else if (right) {
          return "╁";
        } else {
          return "┧";
        }
      } else {
        if (right_bold) {
          return "┢";
        } else if (right) {
          return "┟";
        } else {
          return "╽";
        }
      }
    } else if (down) {
      if (left_bold) {
        if (right_bold) {
          return "┿";
        } else if (right) {
          return "┽";
        } else {
          return "┥";
        }
      } else if (left) {
        if (right_bold) {
          return "┾";
        } else if (right) {
          return "┼";
        } else {
          return "┤";
        }
      } else {
        if (right_bold) {
          return "┝";
        } else if (right) {
          return "├";
        } else {
          return "│";
        }
      }
    } else {
      if (left_bold) {
        if (right_bold) {
          return "┷";
        } else if (right) {
          return "┵";
        } else {
          return "┙";
        }
      } else if (left) {
        if (right_bold) {
          return "┶";
        } else if (right) {
          return "┴";
        } else {
          return "╯";
        }
      } else {
        if (right_bold) {
          return "┕";
        } else if (right) {
          return "╰";
        } else {
          return "╵";
        }
      }
    }
  } else {
    if (down_bold) {
      if (left_bold) {
        if (right_bold) {
          return "┳";
        } else if (right) {
          return "┱";
        } else {
          return "┓";
        }
      } else if (left) {
        if (right_bold) {
          return "┲";
        } else if (right) {
          return "┰";
        } else {
          return "┒";
        }
      } else {
        if (right_bold) {
          return "┏";
        } else if (right) {
          return "┎";
        } else {
          return "╷";  // Best fit.
        }
      }
    } else if (down) {
      if (left_bold) {
        if (right_bold) {
          return "┯";
        } else if (right) {
          return "┭";
        } else {
          return "┑";
        }
      } else if (left) {
        if (right_bold) {
          return "┮";
        } else if (right) {
          return "┬";
        } else {
          return "╮";
        }
      } else {
        if (right_bold) {
          return "┍";
        } else if (right) {
          return "╭";
        } else {
          return "╷";
        }
      }
    } else {
      if (left_bold) {
        if (right_bold) {
          return "━";
        } else if (right) {
          return "╾";
        } else {
          return "╶";  // Best fit.
        }
      } else if (left) {
        if (right_bold) {
          return "╼";
        } else if (right) {
          return "─";
        } else {
          return "╴";
        }
      } else {
        if (right_bold) {
          return "╶";  // Best fit.
        } else if (right) {
          return "╶";
        } else {
          return " ";
        }
      }
    }
  }
}

void GetLineColumnsToDraw(SetLineColumn right, SetLineColumn down,
                          SetLineColumn output) {
  int i = 0;
  while (i < right.size()) {
    LineColumn position = right.get(i);
    output.insert(position);
    output.insert(LineColumn(position.line(), position.column() + 1));
    i = i + 1;
  }

  i = 0;
  while (i < down.size()) {
    LineColumn position = down.get(i);
    output.insert(position);
    output.insert(LineColumn(position.line() + 1, position.column()));
    i = i + 1;
  }
}

bool IsMovingLeft(string c) {
  return ("╴─-´╯.╮+┼┤┴┬╊╆╄╂╀╁┾┨┺┲┦┸┧┰┶┮┚┒╼").find(c, 0) != -1;
}

bool IsMovingLeftBold(string c) {
  return ("╋╉╇╈┿╅╃┽┫┻┳┹┩┪┱┷┯┥┵┭┛┓━┙┑╾").find(c, 0) != -1;
}

bool IsMovingUp(string c) {
  return ("│|`╰´╯+┼┤├┴╵╈┿╆╅╁┽┾┪┢┷┧┟┥┵┝┶╽┙┕").find(c, 0) != -1;
}

bool IsMovingUpBold(string c) {
  return ("╋╉╊╇╄╃╂╀┫┣┻┨┠┹┩┺┡┦┞┸┃┛┗╿┚┖").find(c, 0) != -1;
}

bool IsMovingRight(string c) {
  return ("╶─-`╰,╭+┼├┴┬╉╅╃╂╀╁┽┠┹┱┞┸┟┰┵┭┖┎╾").find(c, 0) != -1;
}

bool IsMovingRightBold(string c) {
  return ("╋╊╇╈┿╆╄┾┣┻┳┺┡┢┲┷┯┝┶┮┗┏┕┍╼━").find(c, 0) != -1;
}

bool IsMovingDown(string c) {
  return ("│|,╭.╮+┼┤├┬╷╇┿╄╃╀┽┾┩┡┯┦┞┥┭┝┮╿┑┍").find(c, 0) != -1;
}

bool IsMovingDownBold(string c) {
  return ("╋╉╊╈╆╅╂╁┫┣┳┨┠┪┱┢┲┧┟┰┃┓┏╽┒┎").find(c, 0) != -1;
}

void DrawLineColumns(SetLineColumn line_column_right,
                     SetLineColumn line_column_down, string code) {
  SetLineColumn line_columns = SetLineColumn();
  GetLineColumnsToDraw(line_column_right, line_column_down, line_columns);
  ShapesSetStatus("Positions to draw: " + line_columns.size().tostring());
  int i = 0;
  while (i < line_columns.size()) {
    LineColumn position = line_columns.get(i);
    string current_code = code;
    if (current_code.empty()) {
      string current_line = buffer.line(position.line());
      string current_char = position.column() < current_line.size()
                                ? current_line.substr(position.column(), 1)
                                : " ";

      bool left = IsMovingLeft(current_char);
      bool left_bold = IsMovingLeftBold(current_char);
      if (position.column() > 0 &&
          line_column_right.contains(
              LineColumn(position.line(), position.column() - 1))) {
        if (delete_mode) {
          left = false;
          left_bold = false;
        } else if (bold_mode) {
          left_bold = true;
        } else {
          left = true;
        }
      }

      bool up = IsMovingUp(current_char);
      bool up_bold = IsMovingUpBold(current_char);
      if (position.line() > 0 && line_column_down.contains(LineColumn(
                                     position.line() - 1, position.column()))) {
        if (delete_mode) {
          up = false;
          up_bold = false;
        } else if (bold_mode) {
          up_bold = true;
        } else {
          up = true;
        }
      }

      bool right = IsMovingRight(current_char);
      bool right_bold = IsMovingRightBold(current_char);
      if (line_column_right.contains(position)) {
        if (delete_mode) {
          right = false;
          right_bold = false;
        } else if (bold_mode) {
          right_bold = true;
        } else {
          right = true;
        }
      }

      bool down = IsMovingDown(current_char);
      bool down_bold = IsMovingDownBold(current_char);
      if (line_column_down.contains(position)) {
        if (delete_mode) {
          down = false;
          down_bold = false;
        } else if (bold_mode) {
          down_bold = true;
        } else {
          down = true;
        }
      }

      current_code = GetCode(up, down, left, right, up_bold, down_bold,
                             left_bold, right_bold);
    }
    DrawPosition(line_columns.get(i), current_code);
    i = i + 1;
  }
}

// output_right contains LineColumn(i, j) if there's a line cross into
// LineColumn(i, j + 1). output_down if there's a line crossing into
// LineColumn(i + 1, j).
void FindBoundariesLine(LineColumn start, LineColumn end,
                        SetLineColumn output_right, SetLineColumn output_down) {
  if (start.column() > end.column()) {
    LineColumn tmp = start;
    start = end;
    end = tmp;
  }
  int delta_x = end.column() - start.column();
  int delta_y = end.line() - start.line();
  double delta_error = (0.0 + delta_y) / delta_x;
  double error = delta_error / 2.0;
  while (start.column() < end.column() ||
         (delta_error >= 0 ? start.line() < end.line()
                           : start.line() > end.line())) {
    if (error > 0.5) {
      error = error - 1.0;
      output_down.insert(start);
      start = LineColumn(start.line() + 1, start.column());
    } else if (error < -0.5) {
      error = error + 1.0;
      start = LineColumn(start.line() - 1, start.column());
      output_down.insert(start);
    } else {
      error = error + delta_error;
      output_right.insert(start);
      start = LineColumn(start.line(), start.column() + 1);
    }
  }
}

void FindBoundariesSquare(LineColumn start, LineColumn end,
                          SetLineColumn output_right,
                          SetLineColumn output_down) {
  FindBoundariesLine(start, LineColumn(start.line(), end.column()),
                     output_right, output_down);
  FindBoundariesLine(start, LineColumn(end.line(), start.column()),
                     output_right, output_down);
  FindBoundariesLine(end, LineColumn(start.line(), end.column()), output_right,
                     output_down);
  FindBoundariesLine(end, LineColumn(end.line(), start.column()), output_right,
                     output_down);
}

void ShapesAddSquareInPositions(LineColumn a, LineColumn b) {
  SetLineColumn output_right = SetLineColumn();
  SetLineColumn output_down = SetLineColumn();
  FindBoundariesSquare(a, b, output_right, output_down);
  DrawLineColumns(output_right, output_down, "");
}

void ShapesAddSquare() {
  LineColumn position = buffer.position();
  ShapesAddSquareInPositions(position, source);
  buffer.set_position(position);
  source = position;
}

bool IsActualContent(string c) {
  string additional = "()";
  return buffer.word_characters().find(c, 0) != -1 ||
         additional.find(c, 0) != -1;
}

string TrimLine(string line) {
  int start = 0;
  while (start < line.size() && !IsActualContent(line.substr(start, 1))) {
    start = start + 1;
  }
  if (start == line.size()) {
    return "";
  }
  int end = line.size() - 1;
  while (end > start && !IsActualContent(line.substr(end, 1))) {
    end = end - 1;
  }
  return line.substr(start, end - start + 1);
}

string GetSquareContents(LineColumn start, LineColumn end) {
  string output = "";
  while (start.line() <= end.line() && start.line() < buffer.line_count()) {
    string line = buffer.line(start.line());
    if (line.size() > start.column()) {
      string part = TrimLine(line.substr(
          start.column(), Min(end.column() + 1, line.size()) - start.column()));
      output = output + (!output.empty() && !part.empty() ? " " : "") + part;
    }
    start = LineColumn(start.line() + 1, start.column());
  }
  return output;
}

string JoinLines(VectorString v) {
  string output = "";
  int i = 0;
  while (i < v.size()) {
    output = output + "[" + v.get(i) + "]";
    i = i + 1;
  }
  return output;
}

string BuildPadding(int size, string c) {
  string output = "";
  while (size > 0) {
    output = output + c;
    size = size - 1;
  }
  return output;
}

void ShapesSquareCenter() {
  LineColumn a = buffer.position();
  LineColumn b = source;
  int border_delta = 1;
  LineColumn start = LineColumn(Min(a.line(), b.line()) + border_delta,
                                Min(a.column(), b.column()) + border_delta);
  LineColumn end = LineColumn(Max(a.line(), b.line()) - border_delta,
                              Max(a.column(), b.column()) - border_delta);
  if (start.line() > end.line() || start.column() > end.column()) {
    ShapesSetStatus("Square is too small.");
    return;
  }
  int width = end.column() - start.column() + 1;
  VectorString contents =
      ShapesReflow(BreakWords(GetSquareContents(start, end)), width);
  int i = 0;
  int start_contents = (end.line() - start.line() + 1 - contents.size()) / 2;
  while (start.line() + i <= end.line()) {
    string input = "";
    if (i >= start_contents && i - start_contents < contents.size()) {
      input = contents.get(i - start_contents);
      int padding = (width - input.size()) / 2;
      input = BuildPadding(padding, " ") + input +
              BuildPadding(width - padding - input.size(), " ");
    } else {
      input = BuildPadding(width, " ");
    }
    DrawPosition(LineColumn(start.line() + i, start.column()), input);
    i = i + 1;
  }
  buffer.set_position(a);
}

void ShapesAddLineToPosition(LineColumn a, LineColumn b) {
  SetLineColumn output_right = SetLineColumn();
  SetLineColumn output_down = SetLineColumn();
  FindBoundariesLine(a, b, output_right, output_down);
  DrawLineColumns(output_right, output_down, "");
}

void ShapesAddLine() {
  LineColumn position = buffer.position();
  ShapesAddLineToPosition(position, source);
  buffer.set_position(position);
  source = position;
}

void ShapesToggleDeleteMode() {
  delete_mode = !delete_mode;
  ShapesSetStatus(delete_mode ? "Delete" : "Insert");
}

void ShapesToggleBoldMode() {
  bold_mode = !bold_mode;
  ShapesSetStatus(bold_mode ? "Bold" : "Normal");
}

void ShapesSet() {
  ShapesSetStatus("Set source position.");
  source = buffer.position();
}

int GetDiagramInputLinesCount() {
  int i = 0;
  while (i < buffer.line_count()) {
    i = i + 1;
    if (SkipSpaces(buffer.line(i)) == "") {
      return i;
    }
  }
  return i;
}

VectorString GetDiagramNouns(int lines) {
  // Use a set to eliminate repetitions.
  SetString nouns = SetString();
  int i = 0;
  while (i < lines) {
    string line = buffer.line(i);
    if (line.substr(0, 1) != " ") {
      nouns.insert(line);
    } else {
      line = SkipSpaces(line);
      int colon = line.find(":", 0);
      if (colon == -1) {
        nouns.insert(line);
      } else {
        nouns.insert(
            SkipSpaces(line.substr(colon + 1, line.size() - (colon + 1))));
      }
    }
    i = i + 1;
  }

  i = 0;
  VectorString output = VectorString();
  while (i < nouns.size()) {
    output.push_back(nouns.get(i));
    i = i + 1;
  }

  return output;
}

VectorInt DiagramGetEdges(int lines, string a, VectorString nouns) {
  string source = "";
  SetString edges = SetString();
  int i = 0;
  while (i < lines) {
    string line = buffer.line(i);
    if (line.substr(0, 1) != " ") {
      source = line;
    } else if (source == a) {
      line = SkipSpaces(line);
      int colon = line.find(":", 0);
      if (colon != -1) {
        line = SkipSpaces(line.substr(colon + 1, line.size() - (colon + 1)));
      }
      edges.insert(line);
    }
    i = i + 1;
  }

  VectorInt output = VectorInt();
  int i = 0;
  while (i < nouns.size()) {
    if (edges.contains(nouns.get(i))) {
      output.push_back(i);
    }
    i = i + 1;
  }
  return output;
}

int GetMaxNounWidth(VectorString nouns) {
  int output = 0;
  int i = 0;
  while (i < nouns.size()) {
    output = Max(output, nouns.get(i).size());
    i = i + 1;
  }
  return output;
}

int GetMaxNounSize(VectorString nouns) {
  int output = 0;
  int i = 0;
  while (i < nouns.size()) {
    output = Max(output, nouns.size());
    i = i + 1;
  }
  return output;
}

VectorString NounLines(string noun) {
  VectorString output = VectorString();
  int start = 0;
  while (start < noun.size()) {
    int next = noun.find(" ", start);
    if (next == -1) {
      next = noun.size();
    }
    output.push_back(noun.substr(start, next - start));
    start = next + 1;
  }
  return output;
}

int NounWidth(VectorString noun_lines) {
  int output = noun_lines.get(0).size();
  int i = 1;
  while (i < noun_lines.size()) {
    output = Max(output, noun_lines.get(i).size());
    i = i + 1;
  }
  return output;
}

VectorLineColumn DiagramGetPositions(int nouns) {
  VectorLineColumn output = VectorLineColumn();
  return output;
}

LineColumn DiagramPositionForNoun(int start, int i, int column_width,
                                  int lines_per_noun) {
  int row = i / 3;
  int column = i - row * 3;
  return LineColumn(start + (row * lines_per_noun), column_width * column);
}

void DiagramDrawEdge(int start, VectorString nouns, int i, int j,
                     int column_width, int lines_per_noun) {
  LineColumn position_i =
      DiagramPositionForNoun(start, i, column_width, lines_per_noun);
  LineColumn position_j =
      DiagramPositionForNoun(start, j, column_width, lines_per_noun);

  VectorString noun_lines_i = NounLines(nouns.get(i));
  VectorString noun_lines_j = NounLines(nouns.get(j));

  ShapesAddLineToPosition(
      LineColumn(
          position_i.line() + (position_i.line() >= position_j.line()
                                   ? 0
                                   : noun_lines_i.size() + 2),
          position_i.column() + (position_i.column() >= position_j.column()
                                     ? 0
                                     : NounWidth(noun_lines_i))),

      LineColumn(
          position_j.line() + (position_j.line() >= position_i.line()
                                   ? 0
                                   : noun_lines_j.size() + 2),
          position_j.column() + (position_j.column() >= position_i.column()
                                     ? 0
                                     : NounWidth(noun_lines_j))));
}

void DiagramDrawEdges(int lines, int start, VectorString nouns,
                      int column_width, int lines_per_noun) {
  int i = 0;
  while (i < nouns.size()) {
    VectorInt edges = DiagramGetEdges(lines, nouns.get(i), nouns);
    int j = 0;
    while (j < edges.size()) {
      SetStatus("Connected: " + nouns.get(i) + "->" + nouns.get(j));
      DiagramDrawEdge(start, nouns, i, edges.get(j), column_width,
                      lines_per_noun);
      j = j + 1;
    }
    i = i + 1;
  }
}

void DrawNouns(int start, VectorString nouns, int column_width,
               int lines_per_noun) {
  int columns = 3;

  int row = 0;
  int column = 0;

  int noun = 0;
  SetStatus("Writing nouns");
  while (noun < nouns.size()) {
    VectorString noun_lines = NounLines(nouns.get(noun));
    LineColumn base_position =
        LineColumn(start + (row * lines_per_noun), column_width * column);

    int line = 0;
    while (line < noun_lines.size()) {
      LineColumn position = LineColumn(base_position.line() + line + 1,
                                       base_position.column() + 1);
      PadToLineColumn(position);
      buffer.InsertText(noun_lines.get(line));
      line = line + 1;
    }

    ShapesAddSquareInPositions(
        base_position,
        LineColumn(base_position.line() + noun_lines.size() + 1,
                   base_position.column() + NounWidth(noun_lines) + 2));

    column = column + 1;
    if (column >= columns) {
      column = 0;
      row = row + 1;
    }

    noun = noun + 1;
  }
}

void ShapesDrawDiagramInner() {
  int lines = GetDiagramInputLinesCount();
  VectorString nouns = GetDiagramNouns(lines);

  buffer.set_position(LineColumn(buffer.line_count(), 0));

  int start = buffer.position().line();
  int column_width = GetMaxNounWidth(nouns) + 6;
  int row_width = GetMaxNounSize(nouns) + 6;
  DrawNouns(start, nouns, column_width, row_width);
  DiagramDrawEdges(lines, start, nouns, column_width, row_width);
}

void ShapesDrawDiagram() { ShapesDrawDiagramInner(); }

buffer.AddBinding("sl", "shapes: line: draw", ShapesAddLine);
buffer.AddBinding("sq", "shapes: square: draw", ShapesAddSquare);
buffer.AddBinding("sc", "shapes: square: center contents", ShapesSquareCenter);
buffer.AddBinding("sd", "shapes: delete_mode = !delete_mode",
                  ShapesToggleDeleteMode);
buffer.AddBinding("s=", "shapes: set source", ShapesSet);
buffer.AddBinding("sb", "shapes: bold_mode = !bold_mode", ShapesToggleBoldMode);
buffer.AddBinding("sD", "shapes: Draw a diagram", ShapesDrawDiagram);
