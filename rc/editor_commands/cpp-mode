string cpp_build_command = "";

void build() {
  if (cpp_build_command == "") {
    SetStatus(
        "Error: Must assign a non-empty value to variable `cpp_build_command`");
    return;
  }
  buffer.SetStatus("Run: " + cpp_build_command);

  string path = buffer.path().shell_escape();
  ForkCommandOptions options = ForkCommandOptions();
  options.set_command("if " + cpp_build_command + "; then "
                      + "edge --run 'Buffer build_buffer = OpenFile(\""
                      + path + "\", false); "
                      + "build_buffer.SetStatus(\"ðŸ—¸ build success\");';"
                      + " else "
                      + "STATUS=$?;"
                      + "edge --run 'Buffer build_buffer = OpenFile(\""
                      + path + "\", false); "
                      + "build_buffer.SetStatus(\"ðŸ’¥ build fail\");';"
                      + "exit $STATUS;"
                      + "fi");
  options.set_insertion_type("only_list");
  options.set_name("build: " + cpp_build_command);
  Buffer build_buffer = ForkCommand(options);
  SetAsCompiler(build_buffer);
}

void CppMode() {
  buffer.set_paragraph_line_prefix_characters(" /*");
  buffer.set_line_prefix_characters(" /*");
  buffer.set_language_keywords(
      "static extern override virtual "
      "class struct private public protected "
      "using typedef namespace "
      "sizeof "
      "static_cast dynamic_cast "
      "delete new "
      // Flow control.
      "switch case default "
      "if else "
      "for while do "
      "break continue "
      "return "
      // Types
      "void const mutable auto "
      "unique_ptr shared_ptr "
      "std function vector list "
      "map unordered_map set unordered_set "
      "int double float string wstring bool char "
      "size_t "
      // Values
      "true false nullptr NULL");
  buffer.set_tree_parser("cpp");
}
